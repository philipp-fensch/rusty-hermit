initSidebarItems({"constant":[["CLOCK_MONOTONIC",""],["CLOCK_REALTIME",""],["HIGH_PRIO",""],["LOW_PRIO",""],["NORMAL_PRIO",""],["NO_PRIORITIES","Maximum number of priorities"],["NSEC_PER_SEC",""],["O_APPEND",""],["O_CREAT",""],["O_EXCL",""],["O_RDONLY",""],["O_RDWR",""],["O_TRUNC",""],["O_WRONLY",""],["RAND_MAX","The largest number `rand` will return"],["STDERR_FILENO",""],["STDIN_FILENO",""],["STDOUT_FILENO",""]],"enum":[["IpAddress","An internetworking address."],["Version","Internet protocol version."]],"fn":[["abort","cause abnormal termination"],["block_current_task","Add current task to the queue of blocked tasl. After calling `block_current_task`, call `yield_now` to switch to another task."],["clock_gettime","get current time"],["close","close a file descriptor"],["exit","cause normal termination and return `arg` to the host system"],["get_priority","Determine the priority of the current thread"],["get_processor_count","determines the number of activated processors"],["getpid","Determines the id of the current thread"],["isatty","returns true if file descriptor `fd` is a tty"],["join","join with a terminated thread"],["network_init","initialize the network stack"],["notify",""],["open","open and possibly create a file"],["rand","The function computes a sequence of pseudo-random integers in the range of 0 to RAND_MAX"],["read","read from a file descriptor"],["secure_rand32","Create a cryptographicly secure 32bit random number with the support of the underlying hardware. If the required hardware isn’t available, the function returns `None`."],["secure_rand64","Create a cryptographicly secure 64bit random number with the support of the underlying hardware. If the required hardware isn’t available, the function returns `None`."],["sem_destroy","sem_destroy() frees the unnamed semaphore at the address pointed to by `sem`."],["sem_init","sem_init() initializes the unnamed semaphore at the address pointed to by `sem`.  The `value` argument specifies the initial value for the semaphore."],["sem_post","sem_post() increments the semaphore pointed to by `sem`. If the semaphore’s value consequently becomes greater than zero, then another thread blocked in a sem_wait call will be woken up and proceed to lock the semaphore."],["sem_timedwait","decrement a semaphore"],["sem_trywait","try to decrement a semaphore"],["spawn","spawn a new thread"],["spawn2","spawn a new thread with user-specified stack size"],["srand","The function sets its argument as the seed for a new sequence of pseudo-random numbers to be returned by `rand`"],["unlink","delete the file it refers to `name`"],["usleep","suspend execution for microsecond intervals"],["wakeup_task","Wakeup task with the thread id `tid`"],["write","write to a file descriptor"],["yield_now","yield the processor"]],"mod":[["tcplistener","`tcplistener` provide an interface to establish tcp socket server."],["tcpstream","`tcpstream` provide an interface to establish tcp socket client."]],"struct":[["Handle","A handle, identifying a socket"],["Ipv4Address","A four-octet IPv4 address."],["Ipv6Address","A sixteen-octet IPv6 address."],["Priority","Priority of a thread"],["timespec","`timespec` is used by `clock_gettime` to retrieve the current time"]],"type":[["Tid","A thread handle type"]]});